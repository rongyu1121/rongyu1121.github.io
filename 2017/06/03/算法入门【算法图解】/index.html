<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>算法入门【算法图解】 · 容与的成长之路</title><meta name="description" content="看的第一本算法书，图很多，讲的很详细，不过觉得讲的有点浅，像是专门给还不是程序员的人看的。
二分查找输入一个有序的列表和一个元素，如果元素包含的列表中返回元素的位置，否则返回null。一般，对于包含n个元素的列表，二分查找需要log2n步，简单查找最多需要n步。
大O表示法，指出了算法运行时间的增速"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">容与的成长之路</a></h3><div class="description"><p>唯江上之清风，与山间之明月，吾与子所共适也。</p></div></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a target="_blank" rel="noopener" href="https://www.caicai.me"> CaiCai </a><span>&</span><a target="_blank" rel="noopener" href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"></a></li></div><div class="avatar"><img src="/asset/avatar.JPG"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>算法入门【算法图解】</a></h3></div><div class="post-content"><p>看的第一本算法书，图很多，讲的很详细，不过觉得讲的有点浅，像是专门给还不是程序员的人看的。</p>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>输入一个有序的列表和一个元素，如果元素包含的列表中返回元素的位置，否则返回null。一般，对于包含n个元素的列表，二分查找需要log2n步，简单查找最多需要n步。</p>
<p>大O表示法，指出了算法运行时间的增速。二分查找表示为O(logn)，括号中叫做操作数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note: If you aren’t familiar with Comparable, please check out “Generics” chapter in Swift book</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">binarySearch</span> &lt;<span class="type">T</span>: <span class="type">Comparable</span>&gt;(<span class="keyword">_</span> <span class="params">list</span>: [<span class="type">T</span>], <span class="params">item</span>: <span class="type">T</span>) -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="comment">// low and high keep track of which part of the list you&#x27;ll search in.</span></span><br><span class="line">    <span class="keyword">var</span> low <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> high <span class="operator">=</span> list.count <span class="operator">-</span> <span class="number">1</span></span><br><span class="line">    <span class="comment">// While you haven&#x27;t narrowed it down to one element ...</span></span><br><span class="line">    <span class="keyword">while</span> low <span class="operator">&lt;=</span> high &#123;</span><br><span class="line">        <span class="comment">//... check the middle element</span></span><br><span class="line">        <span class="keyword">let</span> mid <span class="operator">=</span> low <span class="operator">+</span> (high <span class="operator">-</span> low) <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">let</span> guess <span class="operator">=</span> list[mid]</span><br><span class="line">        <span class="comment">// Found the item.</span></span><br><span class="line">        <span class="keyword">if</span> guess <span class="operator">==</span> item &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// The guess was too high.</span></span><br><span class="line">        <span class="keyword">if</span> guess <span class="operator">&gt;</span> item &#123;</span><br><span class="line">            high <span class="operator">=</span> mid <span class="operator">-</span> <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low <span class="operator">=</span> mid <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myList <span class="operator">=</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="built_in">print</span>(binarySearch(myList, item: <span class="number">3</span>) <span class="operator">??</span> <span class="string">&quot;Not Found&quot;</span>) <span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="built_in">print</span>(binarySearch(myList, item: <span class="operator">-</span><span class="number">1</span>) <span class="operator">??</span> <span class="string">&quot;Not Found&quot;</span>) <span class="comment">// =&gt; Not Found</span></span><br></pre></td></tr></table></figure>

<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>数组预留位置是一种权变措施，可能浪费内存，超过这个值，需要转移。链表元素的内存可以在任何地方，数组是连续内存。链表每个元素存储了下一个元素的位置，链表的优势在插入元素方面，查找元素链表效率低。O(n)叫线性时间，O(1)叫常量时间。删除链表也是优势。数组可以随机访问，链表顺序访问。</p>
<p>选择排序速度不是很快，运行时间为O(n2)。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finds the smallest value in an array</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">findSmallestIndex</span> &lt;<span class="type">T</span>: <span class="type">Comparable</span>&gt; (<span class="keyword">_</span> <span class="params">arr</span>: [<span class="type">T</span>]) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="comment">// Stores the smallest value</span></span><br><span class="line">    <span class="keyword">var</span> smallest <span class="operator">=</span> arr[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// We don&#x27;t need any calculation if the array lenght is 1</span></span><br><span class="line">    <span class="keyword">if</span> arr.count <span class="operator">==</span> <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Stores the index of the smallest value</span></span><br><span class="line">    <span class="keyword">var</span> smallestIndex <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span>arr.count<span class="operator">-</span><span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> arr[i] <span class="operator">&lt;</span> smallest &#123;</span><br><span class="line">            smallest <span class="operator">=</span> arr[i]</span><br><span class="line">            smallestIndex <span class="operator">=</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> smallestIndex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sort array</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">selectionSort</span> &lt;<span class="type">T</span>: <span class="type">Comparable</span>&gt; (<span class="params">arr</span>: [<span class="type">T</span>]) -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> newArr: [<span class="type">T</span>] <span class="operator">=</span> []</span><br><span class="line">    <span class="comment">// We have to make mutableArray reference copy of original array, because Swift 3 doesn&#x27;t allow to get var parameter</span></span><br><span class="line">    <span class="keyword">var</span> mutableArr <span class="operator">=</span> arr</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">...</span>mutableArr.count<span class="operator">-</span><span class="number">1</span> &#123;</span><br><span class="line">       <span class="comment">//Finds the smallest element in the array and adds it to the new array</span></span><br><span class="line">        <span class="keyword">let</span> smallestIndex <span class="operator">=</span> findSmallestIndex(mutableArr)</span><br><span class="line">        newArr.append(mutableArr[smallestIndex])</span><br><span class="line">        mutableArr.remove(at: smallestIndex)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(selectionSort(arr: [<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">10</span>])) <span class="comment">// =&gt; [2, 3, 5, 6, 10]</span></span><br></pre></td></tr></table></figure>

<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>递归函数有基线条件和递归条件，基线条件指的是函数不再调用自己，避免无限循环。递归指的是调用自己。</p>
<p><strong>尾递归</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">fact</span>(<span class="params">x</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x <span class="operator">==</span> <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x<span class="operator">*</span>fact(x: x<span class="operator">-</span><span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fact(x: <span class="number">5</span>)) <span class="comment">// =&gt; 120</span></span><br></pre></td></tr></table></figure>

<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>分而治之D&amp;C，递归式解决方法。</p>
<p><strong>欧几里得算法</strong></p>
<p>涉及数组的递归基线条件通常是数组为空或只有一个元素。</p>
<p><strong>Haskell</strong>，使用递归多，函数式编程。</p>
<p>快速排序比选择排序快，平均运行时间为O(nlogn)，也是最佳时间，每次都随机选择一个元素作为基准值就可以。</p>
<p><strong>合并排序或者也叫归并排序</strong> 也是O(nlogn)。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="comment">//The following implementation of quick sort is little more classic than described in the book, but we have two use this one because of some “slice” feature limitation with array on Swift 3. Main concept is the same</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">quicksort</span> &lt;<span class="type">T</span> : <span class="type">Comparable</span>&gt; (<span class="keyword">_</span> <span class="params">array</span> : [<span class="type">T</span>]) -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.count <span class="operator">&lt;</span> <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// base case, arrays with 0 or 1 element are already &quot;sorted&quot;</span></span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// recursive case</span></span><br><span class="line">        <span class="keyword">let</span> pivot <span class="operator">=</span> array[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">// sub-array of all the elements less than the pivot</span></span><br><span class="line">        <span class="keyword">let</span> less <span class="operator">=</span> array.filter &#123; <span class="variable">$0</span> <span class="operator">&lt;</span> pivot &#125;</span><br><span class="line">        <span class="comment">// sub-array of all the elements equal to the pivot</span></span><br><span class="line">        <span class="keyword">let</span> equal <span class="operator">=</span> array.filter &#123; <span class="variable">$0</span> <span class="operator">==</span> pivot &#125;</span><br><span class="line">        <span class="comment">// sub-array of all the elements greater than the pivot</span></span><br><span class="line">        <span class="keyword">let</span> greater <span class="operator">=</span> array.filter &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> pivot &#125;</span><br><span class="line">        <span class="keyword">return</span> quicksort(less) <span class="operator">+</span> equal <span class="operator">+</span> quicksort(greater)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(quicksort([<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>, <span class="number">16</span>, <span class="number">1</span>])) <span class="comment">// =&gt; [1, 1, 5, 10, 16, 25]</span></span><br></pre></td></tr></table></figure>

<h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h4><p>散列表、散列映射、映射、字典、关联数组，不同的叫法一个概念。应用DNS解析、网页缓存。2个键映射到同一个位置，给这个位置用链表。散列函数将键均匀映射到不同位置，避免冲突。插入删除与链表一样快，查找与数组一样快。填装因子度量的是散列表中的空闲位置，填装因子变大，需要调整长度，通常将数组长度增大一倍。填装因子大于0.7就需要扩增散列表长度。</p>
<p><strong>SHA函数</strong> 用作散列函数。</p>
<h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><p>最短路径问题，用于图查找。运行时间为O(V+E)，V是顶点，E为边数。</p>
<p>队列FIFO，栈LIFO。</p>
<p>有向图，无向图。有依赖关系，叫拓扑排序。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="comment">// As I can see Swift doesn&#x27;t have Queue default implementation, so we have to use custom on, Degue structure from Swift Algorithm Club</span></span><br><span class="line"><span class="comment">// https://github.com/raywenderlich/swift-algorithm-club/tree/master/Deque</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">Deque</span>&lt;<span class="title class_">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> array <span class="operator">=</span> [<span class="type">T</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> array.isEmpty</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> count: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> array.count</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">enqueue</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">T</span>) &#123;</span><br><span class="line">        array.append(element)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">enqueueFront</span>(<span class="keyword">_</span> <span class="params">element</span>: <span class="type">T</span>) &#123;</span><br><span class="line">        array.insert(element, at: <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">dequeue</span>() -&gt; <span class="type">T</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> isEmpty &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> array.removeFirst()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">dequeueBack</span>() -&gt; <span class="type">T</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> isEmpty &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> array.removeLast()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">peekFront</span>() -&gt; <span class="type">T</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> array.first</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">peekBack</span>() -&gt; <span class="type">T</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> array.last</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">persionIsSeller</span>(<span class="params">name</span>: <span class="type">String</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> name.characters.last <span class="operator">==</span> <span class="string">&quot;m&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> graph <span class="operator">=</span> [<span class="type">String</span> : [<span class="type">String</span>]]()</span><br><span class="line">graph[<span class="string">&quot;you&quot;</span>] <span class="operator">=</span> [<span class="string">&quot;alice&quot;</span>, <span class="string">&quot;bob&quot;</span>, <span class="string">&quot;claire&quot;</span>]</span><br><span class="line">graph[<span class="string">&quot;bob&quot;</span>] <span class="operator">=</span> [<span class="string">&quot;anuj&quot;</span>, <span class="string">&quot;peggy&quot;</span>]</span><br><span class="line">graph[<span class="string">&quot;alice&quot;</span>] <span class="operator">=</span> [<span class="string">&quot;peggy&quot;</span>]</span><br><span class="line">graph[<span class="string">&quot;claire&quot;</span>] <span class="operator">=</span> [<span class="string">&quot;thom&quot;</span>, <span class="string">&quot;jonny&quot;</span>]</span><br><span class="line">graph[<span class="string">&quot;anuj&quot;</span>] <span class="operator">=</span> []</span><br><span class="line">graph[<span class="string">&quot;peggy&quot;</span>] <span class="operator">=</span> []</span><br><span class="line">graph[<span class="string">&quot;thom&quot;</span>] <span class="operator">=</span> []</span><br><span class="line">graph[<span class="string">&quot;jonny&quot;</span>] <span class="operator">=</span> []</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">search</span>(<span class="params">name</span>: <span class="type">String</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> searchQueue <span class="operator">=</span> <span class="type">Deque</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">    <span class="comment">//Swift Note: Our custom Deque doesn&#x27;t have possibility to add new element as array so we have to add elements one by one (insted of +=graph[&quot;person&quot;] in the book example)</span></span><br><span class="line">    <span class="keyword">for</span> string <span class="keyword">in</span> graph[name]<span class="operator">!</span> &#123;</span><br><span class="line">        searchQueue.enqueue(string)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// This array is how you keep track of which people you&#x27;ve searched before.</span></span><br><span class="line">    <span class="keyword">var</span> searched <span class="operator">=</span> [<span class="type">String</span>]()</span><br><span class="line">    <span class="keyword">while</span> <span class="operator">!</span>searchQueue.isEmpty &#123;</span><br><span class="line">        <span class="keyword">let</span> person <span class="operator">=</span> searchQueue.dequeue()</span><br><span class="line">        <span class="comment">// Only search this person if you haven&#x27;t already searched them</span></span><br><span class="line">        <span class="keyword">if</span> <span class="operator">!</span>searched.contains(person<span class="operator">!</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> persionIsSeller(name: person<span class="operator">!</span>) &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(person<span class="operator">!</span>)</span> is a mango seller!&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> string <span class="keyword">in</span> graph[person<span class="operator">!</span>]<span class="operator">!</span> &#123;</span><br><span class="line">                    searchQueue.enqueue(string)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Marks this person as searched</span></span><br><span class="line">                searched.append(person<span class="operator">!</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> search(name: <span class="string">&quot;you&quot;</span>) <span class="operator">==</span> <span class="literal">false</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Mango seller Not Found!&quot;</span>)</span><br><span class="line">&#125; <span class="comment">// =&gt; thom is a mango seller!</span></span><br></pre></td></tr></table></figure>

<h4 id="狄克斯特拉算法"><a href="#狄克斯特拉算法" class="headerlink" title="狄克斯特拉算法"></a>狄克斯特拉算法</h4><p>非加权图用广度优先搜索，加权图使用狄克斯特拉算法。环增加权重，不可能是最短路径。狄克斯特拉适用于有向无环图。负权边不能用狄克斯特拉，得用<strong>贝尔曼-福德算法</strong>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="comment">// the graph</span></span><br><span class="line"><span class="keyword">var</span> graph <span class="operator">=</span>  [<span class="type">String</span> : [<span class="type">String</span>: <span class="type">Double</span>]] ()</span><br><span class="line">graph[<span class="string">&quot;start&quot;</span>] <span class="operator">=</span> [<span class="type">String</span>: <span class="type">Double</span>]()</span><br><span class="line">graph[<span class="string">&quot;start&quot;</span>]<span class="operator">?</span>[<span class="string">&quot;a&quot;</span>] <span class="operator">=</span> <span class="number">6</span></span><br><span class="line">graph[<span class="string">&quot;start&quot;</span>]<span class="operator">?</span>[<span class="string">&quot;b&quot;</span>] <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">graph[<span class="string">&quot;a&quot;</span>] <span class="operator">=</span> [<span class="type">String</span>: <span class="type">Double</span>]()</span><br><span class="line">graph[<span class="string">&quot;a&quot;</span>]<span class="operator">?</span>[<span class="string">&quot;fin&quot;</span>] <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">graph[<span class="string">&quot;b&quot;</span>] <span class="operator">=</span> [<span class="type">String</span>: <span class="type">Double</span>]()</span><br><span class="line">graph[<span class="string">&quot;b&quot;</span>]<span class="operator">?</span>[<span class="string">&quot;a&quot;</span>] <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">graph[<span class="string">&quot;b&quot;</span>]<span class="operator">?</span>[<span class="string">&quot;fin&quot;</span>] <span class="operator">=</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line">graph[<span class="string">&quot;fin&quot;</span>] <span class="operator">=</span> [<span class="type">String</span>: <span class="type">Double</span>]()</span><br><span class="line"></span><br><span class="line"><span class="comment">// the costs table</span></span><br><span class="line"><span class="keyword">let</span> infinity <span class="operator">=</span> <span class="type">Double</span>.infinity</span><br><span class="line"><span class="keyword">var</span> costs <span class="operator">=</span> [<span class="type">String</span>: <span class="type">Double</span>]()</span><br><span class="line">costs[<span class="string">&quot;a&quot;</span>] <span class="operator">=</span> <span class="number">6</span></span><br><span class="line">costs[<span class="string">&quot;b&quot;</span>] <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">costs[<span class="string">&quot;fin&quot;</span>] <span class="operator">=</span> infinity</span><br><span class="line"></span><br><span class="line"><span class="comment">// the parents table</span></span><br><span class="line"><span class="keyword">var</span> parents <span class="operator">=</span> [<span class="type">String</span>: <span class="type">String</span>]()</span><br><span class="line">parents[<span class="string">&quot;a&quot;</span>] <span class="operator">=</span> <span class="string">&quot;start&quot;</span></span><br><span class="line">parents[<span class="string">&quot;b&quot;</span>] <span class="operator">=</span> <span class="string">&quot;start&quot;</span></span><br><span class="line">parents[<span class="string">&quot;fin&quot;</span>] <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> processed <span class="operator">=</span> [<span class="type">String</span>]()</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">findLowestCostNode</span>(<span class="params">costs</span>: [<span class="params">String</span>: <span class="type">Double</span>]) -&gt; [<span class="type">String</span>: <span class="type">Double</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> lowestCost <span class="operator">=</span> <span class="type">Double</span>.infinity</span><br><span class="line">    <span class="keyword">var</span> lowestCostNode <span class="operator">=</span> [<span class="type">String</span>: <span class="type">Double</span>]()</span><br><span class="line">    <span class="comment">// Go through each node.</span></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> costs &#123;</span><br><span class="line">        <span class="keyword">let</span> cost <span class="operator">=</span> node.value</span><br><span class="line">        <span class="comment">// If it&#x27;s the lowest cost so far and hasn&#x27;t been processed yet...</span></span><br><span class="line">        <span class="keyword">if</span> (cost <span class="operator">&lt;</span> lowestCost) <span class="operator">&amp;&amp;</span> <span class="operator">!</span>processed.contains(node.key) &#123;</span><br><span class="line">            <span class="comment">// ... set it as the new lowest-cost node.</span></span><br><span class="line">            lowestCost <span class="operator">=</span> cost</span><br><span class="line">            lowestCostNode <span class="operator">=</span> [node.key : node.value]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lowestCostNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find the lowest-cost node that you haven&#x27;t processed yet.</span></span><br><span class="line"><span class="keyword">var</span> node <span class="operator">=</span> findLowestCostNode(costs: costs)</span><br><span class="line"></span><br><span class="line"><span class="comment">// If you&#x27;ve processed all the nodes, this while loop is done.</span></span><br><span class="line"><span class="keyword">while</span> <span class="operator">!</span>node.isEmpty &#123;</span><br><span class="line">    <span class="comment">// Swift Note: Unfortunately there are some limits for working with Dictionary inside Dictionary, so we have to use temp &quot;nodeFirstKey&quot; variable as workaround</span></span><br><span class="line">    <span class="keyword">var</span> nodeFirstKey <span class="operator">=</span> node.first<span class="operator">?</span>.key</span><br><span class="line">    <span class="keyword">var</span> cost <span class="operator">=</span> costs[nodeFirstKey<span class="operator">!</span>]</span><br><span class="line">    <span class="comment">// Go through all the neighbors of this node.</span></span><br><span class="line">    <span class="keyword">var</span> neighbors <span class="operator">=</span> graph[nodeFirstKey<span class="operator">!</span>]</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> (neighbors<span class="operator">?</span>.keys)<span class="operator">!</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> newCost <span class="operator">=</span> cost<span class="operator">!</span> <span class="operator">+</span> (neighbors<span class="operator">?</span>[n])<span class="operator">!</span></span><br><span class="line">        <span class="comment">// If it&#x27;s cheaper to get to this neighbor by going through this node...</span></span><br><span class="line">        <span class="keyword">if</span> costs[n]<span class="operator">!</span> <span class="operator">&gt;</span> newCost &#123;</span><br><span class="line">            <span class="comment">// ... update the cost for this node.</span></span><br><span class="line">            costs[n] <span class="operator">=</span> newCost</span><br><span class="line">            <span class="comment">// This node becomes the new parent for this neighbor.</span></span><br><span class="line">            parents[n] <span class="operator">=</span> nodeFirstKey</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Mark the node as processed.</span></span><br><span class="line">    processed.append(nodeFirstKey<span class="operator">!</span>)</span><br><span class="line">    <span class="comment">// Find the next node to process, and loop.</span></span><br><span class="line">    node <span class="operator">=</span> findLowestCostNode(costs: costs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Cost from the start to each node:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(costs) <span class="comment">// -&gt; [&quot;b&quot;: 2.0, &quot;fin&quot;: 6.0, &quot;a&quot;: 5.0]</span></span><br></pre></td></tr></table></figure>

<h4 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h4><p>每步都选择最优做法，结果与正确结果接近。集合问题的贪婪算法，O(n2)。NP完全问题，需要计算所有的解，选出最好的。NP只能求近似解，非NP能容易算出解。组合、序列、集合可能是NP完全问题，需要考虑所有情况不能分解，数量多变复杂速度变慢。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="comment">// You pass an array in, and it gets converted to a set.</span></span><br><span class="line"><span class="keyword">var</span> statesNeeded : <span class="type">Set</span> <span class="operator">=</span> [<span class="string">&quot;mt&quot;</span>, <span class="string">&quot;wa&quot;</span>, <span class="string">&quot;or&quot;</span>, <span class="string">&quot;id&quot;</span>, <span class="string">&quot;nv&quot;</span>, <span class="string">&quot;ut&quot;</span>, <span class="string">&quot;ca&quot;</span>, <span class="string">&quot;az&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stations <span class="operator">=</span> [<span class="type">String</span>: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;]()</span><br><span class="line">stations[<span class="string">&quot;kone&quot;</span>] <span class="operator">=</span> [<span class="string">&quot;id&quot;</span>, <span class="string">&quot;nv&quot;</span>, <span class="string">&quot;ut&quot;</span>]</span><br><span class="line">stations[<span class="string">&quot;ktwo&quot;</span>] <span class="operator">=</span> [<span class="string">&quot;wa&quot;</span>, <span class="string">&quot;id&quot;</span>, <span class="string">&quot;mt&quot;</span>]</span><br><span class="line">stations[<span class="string">&quot;kthree&quot;</span>] <span class="operator">=</span> [<span class="string">&quot;or&quot;</span>, <span class="string">&quot;nv&quot;</span>, <span class="string">&quot;ca&quot;</span>]</span><br><span class="line">stations[<span class="string">&quot;kfour&quot;</span>] <span class="operator">=</span> [<span class="string">&quot;nv&quot;</span>, <span class="string">&quot;ut&quot;</span>]</span><br><span class="line">stations[<span class="string">&quot;kfive&quot;</span>] <span class="operator">=</span> [<span class="string">&quot;ca&quot;</span>, <span class="string">&quot;az&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> finalStations <span class="operator">=</span> <span class="type">Set</span>&lt;<span class="type">String</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="operator">!</span>statesNeeded.isEmpty &#123;</span><br><span class="line">    <span class="keyword">var</span> bestStation <span class="operator">=</span> <span class="type">String</span>()</span><br><span class="line">    <span class="keyword">var</span> statesCovered <span class="operator">=</span> <span class="type">Set</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> station <span class="keyword">in</span> stations &#123;</span><br><span class="line">        <span class="keyword">var</span> covered <span class="operator">=</span> statesNeeded.intersection(station.value)</span><br><span class="line">        <span class="keyword">if</span> covered.count <span class="operator">&gt;</span> statesCovered.count &#123;</span><br><span class="line">            bestStation <span class="operator">=</span> station.key</span><br><span class="line">            statesCovered <span class="operator">=</span> covered</span><br><span class="line">        &#125;</span><br><span class="line">        statesNeeded <span class="operator">=</span> statesNeeded.subtracting(statesCovered)</span><br><span class="line">        <span class="comment">//Swift note: We should avoid adding empty station to Set</span></span><br><span class="line">        <span class="keyword">if</span> <span class="operator">!</span>bestStation.isEmpty &#123;</span><br><span class="line">            finalStations.insert(bestStation)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(finalStations) <span class="comment">// -&gt; [&quot;kone&quot;, &quot;kfive&quot;, &quot;ktwo&quot;, &quot;kthree&quot;]</span></span><br></pre></td></tr></table></figure>

<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>求最优解，画网格图。依赖于子问题是离散的。应用，DNA相似性、git、diff、拼写检查等。</p>
<h4 id="K最近邻算法"><a href="#K最近邻算法" class="headerlink" title="K最近邻算法"></a>K最近邻算法</h4><p>KNN，分类和回归，分类就是编组，回归是预测。余弦相似度，计算矢量距离。KNN用于机器学习，OCR，人脸识别，语音识别。训练数据。朴素贝叶斯分类器预测垃圾邮件概率。</p>
<h4 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h4><p>二叉查找树，O(logn),插入删除也快，不能随机访问。B树、红黑树、堆、伸展树。搜索引擎，反向索引。傅里叶变换，压缩音视频，地震预测、DNA分析。并行算法。MapReduce,分布式算法，短时间内完成海量工作。布隆过滤器是概率性数据结构，答案不一定准确，占用存储空间小。SHA，根据字符串返回散列值，比较文件，检查密码，simhash，局部敏感，检查相似程度，如论文查重。RSA加密。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-06-03</span><i class="fa fa-tag"></i><a class="tag" href="/tags/图书/" title="图书">图书 </a><a class="tag" href="/tags/算法/" title="算法">算法 </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://rongyu1121.github.io/2017/06/03/算法入门【算法图解】/,容与的成长之路,算法入门【算法图解】,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2017/08/14/%E8%AF%BB%E3%80%90%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E9%93%BE%E6%8E%A5%E3%80%81%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93%E3%80%91/" title="读【程序员的自我修养链接、装载与库】">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2017/05/26/%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8-%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/" title="网络入门【网络是怎样连接的】">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>